#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <memory.h>

int main(int argc,char **argv)
{

/*-----------------------------------------------------------
 *如下第一段代码的作用是:
 *	关闭写端,然后直接从读端读取数据
 *	看read的返回值以及读取的内容.
 *测试结果:ret为0,即读取了0个字节,即ret为空.
 * --------------------------------------------------------*/

/*	int p[2];
	char tmp[128];
	int ret = -1;

	memset(tmp,'\0',128);		//将tmp全部设置为\0.

	pipe(p);			//创建管道.

	close(p[1]);			//p[0] 是读操作,p[1]是写操作.<此处是关闭写端>

	ret = read(p[0],tmp,127);	//从里面读取,但由于里面没有数据,所以读取出来的数据为0.

	printf("%d %s\n",ret,tmp);
	
	close(p[0]);
	*/


/*---------------------------------------------------------
 * 如下代码的作用是:
 * 	从写端写入数据,当read里面的参数小于或大于写入的数据长度时的返回结果.
 *
 * 测试结果:
 *	当读取的大小 大于 读取的内容的长度 ,则会全部读出
 *	当小于的话,则只会读出将要读取的长度
 *意外发现:
 *	我们读取的信息在管道中是  严格按照 FIFO  的顺序,
 *	比如前面读取  10  个字节,后面一个字节也读取不出来,因为前面读完了额...
 * --------------------------------------------------------*/

	int p[2],ret = -1;
	char tmp[128] = {'\0'};

	pipe(p);

	write(p[1],"helloworld",11);
	close(p[1]);

	ret = read(p[0],tmp,7);
	printf("frist:ret = %d,tmp = %s\n",ret,tmp);

	memset(tmp,'\0',128);			//先要是原来的数组为\0,不然会出现错误.

	ret = read(p[0],tmp,3);

	printf("second:ret = %d,tmp = %s\n",ret,tmp);

	return 0;
}
